import json
import logging
import re
from typing import List, Optional, Any

logging.basicConfig(level=logging.INFO)

def format_depends_on(depends_on: List[str]) -> str:
    """
    Formats a list of dependencies into a Terraform-compatible string.

    Parameters:
        depends_on (List[str]): A list of resource dependencies.

    Returns:
        str: A formatted string representing the dependencies in Terraform syntax.
    """
    if not all(isinstance(dep, str) for dep in depends_on):
        raise ValueError("All dependencies must be strings.")
    return ", ".join([f"azion_edge_application_main_setting.{item}" for item in depends_on])

def extract_hostname(behaviors: List[dict]) -> str:
    """
    Extracts the hostname from Akamai behaviors.

    Parameters:
        behaviors (List[dict]): A list of behaviors from Akamai configuration.

    Returns:
        str: The extracted hostname or a placeholder if not found.
    """
    try:
        origin_behavior = next((b for b in behaviors if b.get("name") == "origin"), {})
        return origin_behavior.get("options", {}).get("hostname", "placeholder.example.com")
    except ValueError as e:
        logging.error(f"Error extracting hostname: {e}")
        return "placeholder.example.com"

def log_conversion_summary(resources: List[dict]):
    """
    Logs a summary of the resources generated during conversion.

    Parameters:
        resources (List[dict]): A list of resources generated by the conversion process.
    """
    resource_types = [res["type"] for res in resources if "type" in res]

    logging.info(f"Conversion summary: {len(resources)} resources generated.")
    
    if resource_types:
        logging.info(f"Generated resources: {', '.join(set(resource_types))}")


def write_indented(f, content, indent_level=0, indent_size=4):
    """
    Writes indented content to a file.

    Parameters:
        f (file object): The file to write to.
        content (str): The content to write.
        indent_level (int): The level of indentation.
        indent_size (int): The number of spaces per indentation level.
    """
    indentation = " " * (indent_level * indent_size)
    f.write(indentation + content + "\n")

def write_list_items(f, items, indent_level=2):
    """
    Writes a list of items in Terraform format, ensuring no trailing comma.

    Parameters:
        f (file object): The file to write to.
        items (list): The list of items to write.
        indent_level (int): The level of indentation.
    """
    if not isinstance(items, list) or not items:
        raise ValueError("items must be a non-empty list")

    for idx, item in enumerate(items):
        comma = "," if idx < len(items) - 1 else ""  # Add a comma only if not the last item
        write_indented(f, f"{item}{comma}", indent_level)

def sanitize_name(name: str) -> str:
    """
    Sanitize a name to be used as a Terraform resource name.
    
    Rules:
    1. Only lowercase letters, numbers, and underscores
    2. Must start with a letter
    3. Cannot start with a number or special character
    4. Replace special characters and spaces with underscores
    5. Remove consecutive underscores
    6. Remove leading/trailing special characters
    
    Parameters:
        name (str): Name to sanitize
        
    Returns:
        str: Sanitized name safe for Terraform resource naming
    """
    if not name:
        return "unnamed_resource"
        
    # Step 1: Convert to lowercase and replace special chars with underscore
    sanitized = name.lower()
    
    # Step 2: Replace common special characters and punctuation
    special_chars = {
        '.': '_',
        '/': '_',
        '\\': '_',
        '-': '_',
        ' ': '_',
        ':': '_',
        ',': '_',
        ';': '_',
        '(': '_',
        ')': '_',
        '[': '_',
        ']': '_',
        '{': '_',
        '}': '_',
        '|': '_',
        '&': '_and_',
        '+': '_plus_',
        '=': '_equals_',
        '*': '_star_',
        '@': '_at_',
        '#': '_hash_',
        '$': '_dollar_',
        '%': '_percent_',
        '!': '_',
        '?': '_',
        '"': '_',
        "'": '_',
        '`': '_',
        '^': '_',
        '~': '_',
        '<': '_',
        '>': '_',
    }
    
    for char, replacement in special_chars.items():
        sanitized = sanitized.replace(char, replacement)
    
    # Step 3: Handle non-ASCII characters (like accented characters)
    sanitized = ''.join(c if c.isascii() and (c.isalnum() or c == '_') else '_' 
                       for c in sanitized)
    
    # Step 4: Remove consecutive underscores
    while '__' in sanitized:
        sanitized = sanitized.replace('__', '_')
    
    # Step 5: Remove leading/trailing underscores
    sanitized = sanitized.strip('_')
    
    # Step 6: Ensure it starts with a letter
    if not sanitized or not sanitized[0].isalpha():
        sanitized = 'r_' + sanitized
    
    # Step 7: If empty after sanitization, return default name
    if not sanitized:
        return "unnamed_resource"
        
    return sanitized

# Compile regex patterns once for better performance
_TRUE_PATTERN = re.compile(r'\bTrue\b')
_FALSE_PATTERN = re.compile(r'\bFalse\b')
_NONE_PATTERN = re.compile(r'\bNone\b')

def clean_and_parse_json(json_string: str) -> Optional[Any]:
    """
    Clean and parse a JSON string.
    
    :param json_string: String containing the JSON.
    :return: Parsed JSON object or None if parsing fails.
    """
    if not json_string:
        logging.error("Empty JSON string provided")
        return None

    try:
        if json_string.startswith("${jsonencode(") and json_string.endswith(")}"):
            extracted_content = json_string[len("${jsonencode("):-2].strip()
        else:
            extracted_content = json_string
        
        rules_cleaned = extracted_content.replace("'", '"')
        rules_cleaned = _TRUE_PATTERN.sub('true', rules_cleaned)
        rules_cleaned = _FALSE_PATTERN.sub('false', rules_cleaned)
        rules_cleaned = _NONE_PATTERN.sub('null', rules_cleaned)

        return json.loads(rules_cleaned)
    except json.JSONDecodeError as e:
        logging.error(f"JSON decode error: {str(e)}")
        return None
    except Exception as e:
        logging.error(f"Unexpected error while parsing JSON: {str(e)}")
        return None

def parse_ttl(ttl_str):
    """
    Converts a time-to-live (TTL) string into seconds.

    Supported formats:
    - 'Nd' for days (e.g., '2d' -> 172800 seconds)
    - 'Nh' for hours (e.g., '3h' -> 10800 seconds)
    - 'Nm' for minutes (e.g., '45m' -> 2700 seconds)
    - Numeric only for seconds (e.g., '60' -> 60 seconds)

    Parameters:
        ttl_str (str): A string representing the TTL.

    Returns:
        int: The TTL value in seconds.

    Raises:
        ValueError: If the string format is invalid or not supported.
    """
    # Check if the input is a string; raise an error otherwise
    if not isinstance(ttl_str, str):
        raise ValueError(f"Invalid input: expected a string, received {type(ttl_str).__name__}")

    # Remove unnecessary whitespace from the input string
    ttl_str = ttl_str.strip()

    # Check if the string ends with 'd' (days), and convert to seconds if valid
    if ttl_str.endswith('d'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 86400  # Convert days to seconds

    # Check if the string ends with 'h' (hours), and convert to seconds if valid
    elif ttl_str.endswith('h'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 3600  # Convert hours to seconds

    # Check if the string ends with 'm' (minutes), and convert to seconds if valid
    elif ttl_str.endswith('m'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 60  # Convert minutes to seconds

    # If the string contains only digits, interpret it as seconds
    elif ttl_str.isdigit():
        return int(ttl_str)

    # If none of the conditions match, raise a ValueError for invalid format
    raise ValueError(f"Invalid TTL format: {ttl_str}")
