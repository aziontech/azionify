import ast
import json
import logging
import re
from typing import List, Optional, Any, Dict

logging.basicConfig(level=logging.INFO)

# Compile regex patterns once for better performance
_TRUE_PATTERN = re.compile(r'\bTrue\b')
_FALSE_PATTERN = re.compile(r'\bFalse\b')
_NONE_PATTERN = re.compile(r'\bNone\b')

def format_depends_on(depends_on: List[str]) -> str:
    """
    Formats a list of dependencies into a Terraform-compatible string.

    Parameters:
        depends_on (List[str]): A list of resource dependencies.

    Returns:
        str: A formatted string representing the dependencies in Terraform syntax.
    """
    if not all(isinstance(dep, str) for dep in depends_on):
        raise ValueError("All dependencies must be strings.")
    return ", ".join([f"azion_edge_application_main_setting.{item}" for item in depends_on])

def extract_hostname(behaviors: List[dict]) -> str:
    """
    Extracts the hostname from Akamai behaviors.

    Parameters:
        behaviors (List[dict]): A list of behaviors from Akamai configuration.

    Returns:
        str: The extracted hostname or a placeholder if not found.
    """
    try:
        origin_behavior = next((b for b in behaviors if b.get("name") == "origin"), {})
        return origin_behavior.get("options", {}).get("hostname", "placeholder.example.com")
    except ValueError as e:
        logging.error(f"Error extracting hostname: {e}")
        return "placeholder.example.com"

def log_conversion_summary(resources: List[dict]):
    """
    Logs a summary of the resources generated during conversion.

    Parameters:
        resources (List[dict]): A list of resources generated by the conversion process.
    """
    resource_types = [res["type"] for res in resources if "type" in res]

    logging.info(f"Conversion summary: {len(resources)} resources generated.")
    
    if resource_types:
        logging.info(f"Generated resources: {', '.join(set(resource_types))}")

def write_indented(f, content, indent_level=0, indent_size=4):
    """
    Writes indented content to a file.

    Parameters:
        f (file object): The file to write to.
        content (str): The content to write.
        indent_level (int): The level of indentation.
        indent_size (int): The number of spaces per indentation level.
    """
    indentation = " " * (indent_level * indent_size)
    f.write(indentation + content + "\n")

def write_list_items(f, items, indent_level=2):
    """
    Writes a list of items in Terraform format, ensuring no trailing comma.

    Parameters:
        f (file object): The file to write to.
        items (list): The list of items to write.
        indent_level (int): The level of indentation.
    """
    if not isinstance(items, list) or not items:
        raise ValueError("items must be a non-empty list")

    for idx, item in enumerate(items):
        comma = "," if idx < len(items) - 1 else ""  # Add a comma only if not the last item
        write_indented(f, f"{item}{comma}", indent_level)

def sanitize_name(name: str) -> str:
    """
    Sanitize a name to be used as a Terraform resource name.
    
    Rules:
    1. Only lowercase letters, numbers, and underscores
    2. Must start with a letter
    3. Cannot start with a number or special character
    4. Replace special characters and spaces with underscores
    5. Remove consecutive underscores
    6. Remove leading/trailing special characters
    
    Parameters:
        name (str): Name to sanitize
        
    Returns:
        str: Sanitized name safe for Terraform resource naming
    """
    if not name:
        return "unnamed_resource"
        
    # Step 1: Convert to lowercase and replace special chars with underscore
    sanitized = name.lower()
    
    # Step 2: Replace common special characters and punctuation
    special_chars = {
        '.': '_',
        '/': '_',
        '\\': '_',
        '-': '_',
        ' ': '_',
        ':': '_',
        ',': '_',
        ';': '_',
        '(': '_',
        ')': '_',
        '[': '_',
        ']': '_',
        '{': '_',
        '}': '_',
        '|': '_',
        '&': '_and_',
        '+': '_plus_',
        '=': '_equals_',
        '*': '_star_',
        '@': '_at_',
        '#': '_hash_',
        '$': '_dollar_',
        '%': '_percent_',
        '!': '_',
        '?': '_',
        '"': '_',
        "'": '_',
        '`': '_',
        '^': '_',
        '~': '_',
        '<': '_',
        '>': '_',
    }
    
    for char, replacement in special_chars.items():
        sanitized = sanitized.replace(char, replacement)
    
    # Step 3: Handle non-ASCII characters (like accented characters)
    sanitized = ''.join(c if c.isascii() and (c.isalnum() or c == '_') else '_' 
                       for c in sanitized)
    
    # Step 4: Remove consecutive underscores
    while '__' in sanitized:
        sanitized = sanitized.replace('__', '_')
    
    # Step 5: Remove leading/trailing underscores
    sanitized = sanitized.strip('_')
    
    # Step 6: Ensure it starts with a letter
    if not sanitized or not sanitized[0].isalpha():
        sanitized = 'r_' + sanitized
    
    # Step 7: If empty after sanitization, return default name
    if not sanitized:
        return "unnamed_resource"
        
    return sanitized

def clean_and_parse_json(json_string: str) -> Optional[Any]:
    """
    Clean and parse a JSON or HCL string.
    
    :param json_string: String containing the JSON or HCL.
    :return: Parsed object or None if parsing fails.
    """
    if not json_string:
        logging.debug("Empty string provided for parsing.")
        return None

    try:
        # First try to parse as JSON
        try:
            return json.loads(json_string)
        except json.JSONDecodeError:
            logging.debug("String was not initialy a parseable json.")
            pass
        
        # If string starts with ${jsonencode(...)}, extract the content
        if json_string.startswith('${jsonencode(') and json_string.endswith(')}'):
            # Extract content between jsonencode( and the last )
            json_string = json_string[len('${jsonencode('):-2]
            
            # Replace single quotes with double quotes, but only if they're not within a string
            in_string = False
            escaped = False
            result = []
            for char in json_string:
                if char == '\\' and not escaped:
                    escaped = True
                    result.append(char)
                    continue
                    
                if char == '"' and not escaped:
                    in_string = not in_string
                    result.append(char)
                elif char == "'" and not in_string and not escaped:
                    result.append('"')
                else:
                    result.append(char)
                    
                escaped = False
                
            json_string = ''.join(result)
            
            try:
                # Try to parse the cleaned string
                return json.loads(json_string)
            except json.JSONDecodeError:
                pass
                
            try:
                # If that fails, try to evaluate it as a Python literal
                return ast.literal_eval(json_string)
            except Exception:
                pass
        
        # Try to parse as a plain object
        try:
            json_string = json_string.replace("'", '"')
            return json.loads(json_string)
        except Exception:
            pass
        
        logging.error("Failed to parse content as either JSON or HCL")
        return None
            
    except Exception as e:
        logging.error(f"Error parsing content: {str(e)}")
        return None

def parse_ttl(ttl_str):
    """
    Converts a time-to-live (TTL) string into seconds.

    Supported formats:
    - 'Nd' for days (e.g., '2d' -> 172800 seconds)
    - 'Nh' for hours (e.g., '3h' -> 10800 seconds)
    - 'Nm' for minutes (e.g., '45m' -> 2700 seconds)
    - Numeric only for seconds (e.g., '60' -> 60 seconds)

    Parameters:
        ttl_str (str): A string representing the TTL.

    Returns:
        int: The TTL value in seconds.

    Raises:
        ValueError: If the string format is invalid or not supported.
    """
    # Check if the input is a string; raise an error otherwise
    if not isinstance(ttl_str, str):
        raise ValueError(f"Invalid input: expected a string, received {type(ttl_str).__name__}")

    # Remove unnecessary whitespace from the input string
    ttl_str = ttl_str.strip()

    # Check if the string ends with 'd' (days), and convert to seconds if valid
    if ttl_str.endswith('d'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 86400  # Convert days to seconds

    # Check if the string ends with 'h' (hours), and convert to seconds if valid
    elif ttl_str.endswith('h'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 3600  # Convert hours to seconds

    # Check if the string ends with 'm' (minutes), and convert to seconds if valid
    elif ttl_str.endswith('m'):
        value = ttl_str[:-1]  # Extract the numeric part
        if value.isdigit():
            return int(value) * 60  # Convert minutes to seconds

    # If the string contains only digits, interpret it as seconds
    elif ttl_str.isdigit():
        return int(ttl_str)

    # If none of the conditions match, raise a ValueError for invalid format
    raise ValueError(f"Invalid TTL format: {ttl_str}")

def resources_filter_by_type(resources: List[Dict[str, Any]], resource_type: str) -> List[Dict[str, Any]]:
    """
    Filtra os objetos de 'resources' pelo campo 'type'.

    Par√¢metros:
        resources (List[Dict[str, Any]]): Lista de objetos a ser filtrada.
        resource_type (str): O valor do campo 'type' a ser pesquisado.

    Retorna:
        List[Dict[str, Any]]: Lista de objetos com o campo 'type' correspondente.
    """
    filtered_resources = [resource for resource in resources if resource.get("type") == resource_type]
    return filtered_resources
